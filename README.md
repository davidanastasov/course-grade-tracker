# Документација - Course Grade Tracker

**Изработено од:** Давид Анастасов - 216076

**Предмет:** Континуирана Интеграција и Испорака

**Професори:** д-р Панче Рибарски и м-р Стефан Андонов

Факултет за информатички науки и компјутерско инженерство

---

- GitHub репозиториум: [http://github.com/davidanastasov/course-grade-tracker](http://github.com/davidanastasov/course-grade-tracker)
- Docker Hub Frontend: [https://hub.docker.com/r/davidanastasov/course-grade-tracker-frontend](https://hub.docker.com/r/davidanastasov/course-grade-tracker-frontend)
- Docker Hub Backend: [https://hub.docker.com/r/davidanastasov/course-grade-tracker-backend](https://hub.docker.com/r/davidanastasov/course-grade-tracker-backend)

## 1. Краток опис на проектот

Проектот „Course Grade Tracker“ е веб апликација развиена како дел од предметот Континуирана Интеграција и Испорака (CI/CD), со цел да се демонстрира практична примена на DevOps алатки и процеси. Апликацијата овозможува студентите да се запишат на курсеви, да ги следат своите поени по компоненти на оценување (теорија, лаборатории, проекти и сл.), и врз основа на тие поени да добијат проекција за крајната оцена. Професорите, пак, можат да креираат курсеви со сопствена структура на оценување, да поставуваат задачи и лаборатории, и да ги потврдуваат финалните оценки на студентите.

Апликацијата е целосно изработена специјално за овој предмет и не користи претходно подготвен код од други проекти. Претставува три-слојна архитектура: frontend (SPA изработен во React), backend (NestJS API), и база на податоци (MongoDB). Фокусот на проектот не е самата функционалност, туку интеграцијата на развојната околина со алатки како Docker, Docker Compose, GitHub Actions и Kubernetes, со цел да се воспостави целосна CI/CD платформа.

## 2. Архитектура на апликацијата

Апликацијата „Course Grade Tracker“ следи класична три-слојна архитектура, составена од:

- Frontend – SPA изработен со React и Vite, со UI компоненти базирани на shadcn/ui (TailwindCSS). Оваа апликација комуницира со backend преку REST API и е изградена да работи целосно клиентски (browser-based).

- Backend (API) – NestJS сервер кој ги имплементира сите бизнис логики: регистрација и најава на корисници, креирање и управување со курсеви, следење и проекција на поени и оценки, како и управување со лаборатории и задачи. Автентикацијата е базирана на JWT и е ролно-зависна (студент/професор).

- База на податоци – MongoDB NoSQL база, користена за складирање на сите податоци поврзани со корисници, курсеви, оценки, задачи и лаборатории. Базата се наоѓа во сопствен Kubernetes StatefulSet со перзистентен волумен.

Структурата на апликацијата е следна: one level deep
k8s, compose include these too

```
Course Grade Tracker
├── frontend (React + Vite)
├── backend (NestJS API)
├── k8s (Kubernetes manifests)
└── compose (Docker Compose configuration)
```

### Комуникација помеѓу компонентите

Frontend апликацијата испраќа REST повици до backend сервисот преку Ingress route.

Backend комуницира со базата преку интерен Kubernetes сервис.

Пријавувањето и регистрацијата резултираат со добивање JWT токен кој се чува на клиентот и се испраќа со секој повик до API-то.

Swagger документацијата на backend-от е достапна и користена за поедноставена интеграција.

#### Забелешка:

Во оваа верзија апликацијата е имплементирана како монолит, со сите backend функционалности споени во една NestJS апликација. Ова овозможува поедноставена почетна реализација и лесно локално тестирање. Сепак, архитектурата овозможува понатамошно разделување на функционалностите во микросервиси доколку е потребно.

## 3. Алатки за CI/CD

Проектот е структуриран со целосен фокус на автоматизација на процесите за градење, тестирање и деплојмент, преку примена на современи DevOps алатки. Главните алатки кои се користат за континуирана интеграција и испорака се:

#### GitHub Actions

Избраната CI платформа е GitHub Actions, бидејќи овозможува директна интеграција со GitHub репозиториумот. Секој пат кога ќе се направи push на главната гранка (master), се активира pipeline кој:

- Го гради backend и frontend како Docker слики
- Ги пушта сликите на Docker Hub
- По избор, извршува автоматизиран деплојмент на Kubernetes кластер

#### Docker

Сите компоненти на апликацијата (frontend, backend и база) се комплетно docker-изирани со свои Dockerfile конфигурации. Ова овозможува унифицирано работење независно од средината каде се извршуваат.

#### Docker Compose

За локално развивање и тестирање, се користи docker-compose.yml конфигурација која ги оркестрира трите главни сервиси – frontend, backend и MongoDB база – и ги поврзува преку заедничка мрежа. Сепак, овој проект не користи docker-compose за продукциска околина, туку се Kubernetes за оркестрација иако би можело тоа да се направи и со Docker Compose.

#### Kubernetes

За продукциска или staging околина, апликацијата е подготвена за работа во Kubernetes кластер. Секој сервис има свој Deployment и Service YAML манифести, базата користи StatefulSet со Persistent Volume, а конфигурациите и тајните се управуваат преку ConfigMaps и Secrets. Исто така, поставен е и Ingress за пристап до frontend и backend од надворешниот свет.

#### K3d (локално Kubernetes тестирање)

За симулирање на кластер во dev средина, се користи k3d, кој овозможува локално креирање и тестирање на Kubernetes кластери без потреба од cloud провајдер.

## 4. Docker

Секоја компонента на апликацијата (frontend и backend) е изолирана и спакувана во сопствен Docker image, со користење на multi-stage builds за подобра ефикасност и безбедност. Овој пристап овозможува финалните слики да бидат лесни, брзи и без непотребни build-time зависности.

#### Docker-изирање на Frontend

За frontend апликацијата, се користат две фази:

- Build фаза

  Во првата фаза се користи node:alpine слика каде што се инсталираат зависностите и се гради апликацијата со npm run build. Во оваа фаза, исто така се внесува build-time аргумент VITE_API_BASE_URL, кој овозможува API-то да се конфигурира според околината (на пример staging или production).

- Production фаза (Nginx)

  Изградената SPA апликација се сервира преку nginx:alpine, со прилагодена nginx.conf конфигурација. Оваа фаза овозможува оптимизирано сервирање на статички фајлови, поддршка за SPA routing, долготрајно кеширање на assets (до 1 година), и gzip компресија за побрзо вчитување.

Користењето на multi-stage значи дека final image-от не ја содржи ниту Node.js средината ниту дев зависности – само чисти, излезни статики спремни за продукција.

Излезниот image содржи само nginx сервер кој што е конфигуриран да ги сервира статичките излезни фајлови од frontend апликацијата. Ова го прави image-от многу мал и брз за стартување.

#### Docker-изирање на Backend

Backend апликацијата, изградена со NestJS, е docker-изирана преку две фази во Dockerfile-от. Во првата фаза се инсталираат сите зависности и се гради апликацијата, додека во втората — production фаза — се копира само изградената апликација и се инсталираат само потребните production зависности, со што се добива полесна и побезбедна финална слика.

Дополнително, се користи неприпривилегиран корисник (nestjs) наместо root, се креира директориум за runtime фајлови (uploads/) со соодветни привилегии, и се дефинира HEALTHCHECK за да се олесни надгледување на сервисот во Kubernetes.

## 5. Docker Compose

Docker Compose се користи за едноставно оркестрација на frontend, backend и базата на податоци. Секој сервис има сопствен build context, при што frontend-от добива влезни аргументи, а backend-от користи .env фајлови за подобра изолација на конфигурациите. Базата (MongoDB) е поставена со healthcheck механизам за да се осигура дека backend-от стартува само кога базата е спремна, што значително го намалува непотребното чекање. Постојат две мрежи — јавна и приватна — со цел да се ограничи пристапот до базата, и се користат named volumes за перзистенција на податоците и прикачените фајлови.

## 6. GitHub Actions

GitHub Actions се користи за автоматизација на целосниот процес на градење и деплојмент на frontend и backend деловите од апликацијата. Секој пат кога ќе се направи промена во кодот, системот ги извршува потребните проверки на квалитетот на кодот, како што се форматирање и linting, а потоа ја гради апликацијата со соодветните конфигурации за тековната околина.

По успешното градење, Docker сликите се креираат и се пуштаат на регистар за слики, со јасна разделба помеѓу различните работни околини (на пр. развојна и продукциска). Ова овозможува ефикасен и автоматизиран пристап за понатамошен деплојмент на апликацијата, со минимална рачна интервенција и висок степен на доверливост во процесот.

## 7. Kubernetes

За оркестрација и деплојмент на апликацијата се користат Kubernetes манифести кои ги опфаќаат сите главни компоненти: frontend, backend, и базата на податоци (MongoDB). Апликацијата е распоредена во посебен namespace за подобра организација и изолација на ресурсите.

Секој сервис има свој Deployment или StatefulSet (за базата) со дефинирани ресурсни лимити и барања, што помагаат во оптимална распределба на ресурси во кластерот. За backend и frontend е поставен Horizontal Pod Autoscaler (HPA) кој овозможува автоматско скалирање според оптоварувањето на CPU, со дефинирани минимални и максимални броеви на реплики за да се обезбеди висока достапност и оптимална перформанса.

За backend сервисот е имплементирана и readiness и liveness probe, кои овозможуваат Kubernetes автоматски да ја следи здравствената состојба на апликацијата и да изврши auto healing (рестартирање на нефункционални подови). Исто така, сите Deployments имаат конфигурирано автоматско rollout обновување, што овозможува безпрекорна имплементација на нови верзии без прекини во работата.

За базата на податоци се користи StatefulSet со PersistentVolumeClaim за перзистентно складирање, што гарантира зачувување на податоците и нивна достапност и при рестартирање на подовите. За комуникација и мрежна изолација се користат Services и Ingress ресурс кој овозможува пристап до апликацијата преку HTTP со правилно маршрутирање на API повиците и frontend-от.

Секретите и конфигурациите се хостирани во посебни ConfigMap и Secret ресурси, што овозможува безбедно управување со чувствителни податоци како што се кориснички имиња, лозинки и JWT клучеви.

## 8. Континуирана интеграција и испорака (CI/CD)

Процесот на континуирана интеграција и испорака (CI/CD) е целосно автоматизиран преку GitHub Actions. Секоја промена во кодот која се пушта на дефинираните гранки (на пр. master и dev) ја активира изградбата и тестирањето на апликацијата. Во првата фаза се извршуваат статички проверки како linting и форматирање, за да се обезбеди квалитетот на кодот. Потоа, апликацијата се гради со конфигурации соодветни на околината, а Docker сликите за frontend и backend се креираат и пуштаат во регистар.

Во следната фаза, овие слики се автоматски деплојраат на Kubernetes кластерот, што овозможува секогаш да се тестира и демонстрира најновата стабилна верзија на апликацијата. Ова овозможува брзо и сигурно пуштање нови функционалности со минимален човечки фактор и голема доверливост во процесот. Воедно, автоматизацијата значително го намалува времето потребно за рутински задачи и ја подобрува кохезијата помеѓу тимовите што работат на проектот.
